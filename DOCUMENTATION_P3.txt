*******************************************************************

 Project 3 Documentation

 Nick Antonelli 5113-5181
 Saturday, April 21, 2012

*******************************************************************

=====================================
 Table of Contents
=====================================

1.  Compilation

2. Known Problems

3.  Basic Usage
  a.  Client
  b.  Server

4. Client Commands

5.  Messages
  a.  General Structure

  b.  Types
    i.  INSERT
   ii.  DELETE
  iii.  GET
   iv.  TRANSMIT
    v.  LINK
   vi.  UNLINK
  vii.  REGISTER
  vii.  UNREGISTER
   ix.	LIST
    x.	SEND
  xii.	SEND_N
 xiii.  SEND_F
   xi.  GAMEOVER

  c. Error Codes

6. Routing Algorithm

7. Test Cases

============================================
 1. Compilation
============================================

Compilation is simple. A makefile is provided for convenient
use. Simply type

make

and the program will compile. When cleaning the current directory
of files, type

make clean

and all the class files will be removed.

============================================
 2. Known Problems
============================================

There are currently no known problems with the system.

============================================
 3. Basic Usage
============================================

a. Client

To use the client, simply type

java Client

and the client application will start. The client establishes UDP
connections with servers and communicates with them by translating
user input into special message packets. Each time a send/receive
pair is done, the user is prompted for input at the dollar sign ($),
much as what one does in BASH. If an error occurs, or if the command
submitted to the ClientProtocol is unknown, errors will appear on the
screen.

**NOTE** The client initially is not connected to any server. The user
must first give the application an IP and port on which to connect. Please
see Section 3: Client Commands for the method in which to do this.

b. Server

To use the server, simply type

java Server [port] [name]

and the client application will start. Note that the user may start
the server with a given port number. In fact, there are three possible
ways that the server can get a port number:

    1. Passed as argument to application;
    2. Specified in config.ini;
    3. Specified at 8080.

The order given indicates the preference given when determining the port.
That is, if the user passes a non valid port number (outside of the range
1024 <= port# <= 65535) via command line, the application tries to get the
port from the config file. If for some reason the config file is unable to
return a valid port number, the port is simply specified as 8080.

In addition, the user may specify a name for the server or may let the
configuration file define the server name. If there is no name, the
application exits.

Once started, the server is self-running. It will continue operating until
a client issues a GAMEOVER packet. (See Section 3: Client Commands for more.)
Otherwise, the server will run until stopped by the user.

On shutdown, the server will serialize the records it has into Records.db.
This file is opened on startup, so any records placed in it will be
automatically inserted. The following format defines how Records.db
expects the serialized records to look like:

name; IP; port

============================================
 4. Client Commands
============================================

The following are the commands the client can perform. This section does not
deal with the actual message packets that are sent between the client and
server. Arguments denoted in [] are optional, while those denoted in {} are
required.

Finally, the user may supply arguments in the command, or may wait for the
client application to ask for the information. Any information passed in
via the initial user input is checked against the expected input, and
if it fails the check the user will be prompted to enter valid data.

- server {IP} {port}

  Tells the application to use the given IP and port pair as the server
  to contact. A test ping is done to ensure that the server exists; if it does
  not, or if it does not respond within 5 seconds, an error message is printed
  out and the client's variables are not set to send to that IP/port pair.

- insert {IP} {port}

  Inserts the name and IP/port pair into the server's records database.
  The server queries the address with a GET_NAME message to get the
  server's name.

- delete {name} {IP|"null"} {port|0}

  Deletes the named record from the server's records database. If the IP and
  port are specified as well, they must also match those provided in the record
  in order to delete the record.

  "null" and 0 both are used to indicate that the field is to be ignored
  during the search for the record. Should the server get a message
  with "null" in the IP field, for example, the server will not consider
  IP addresses during the process of finding a match. 

- find {name | name regex} {IP | IP regex}
  Get searches for records in the remote server that match the inputs
  provided by the client. For the name, the user may specify an alphanumeric
  string or simply the * wildcard. For the IP address, one or all the
  subcomponents may specify numeric characters or the wildcard *.

  The server takes this information and then attempts to find records
  that match the given input. A RECORD_NOT_FOUND error is generated
  if there are no records to report. Otherwise, the client receives
  the number of matched records and the records themselves.

- link {n|ip} {server|IP port}
  Adds a logical link from the active server to the specified record.
  The two machines exchange client lists in the process. May return
  SERVER_NOT_KNOWN if the server isn't known to the active server,
  SERVER_ALREADY_LINKED if the server is logically connected already
  and TIMEOUT if the test connection times out.

  The link can be generated by either naming the record or by specifying
  the IP and port of the server. The user first types 'n' to indicate a
  name will be passed or 'ip' to indicate an IP/port pair will be
  passed to the server. Once at the server, the server looks for the correct
  record based on the available information.

- unlink {n|ip} {server|IP port}
  Removes the logical link between the active server and the specified
  server. May return SERVER_NOT_KNOWN if the server isn't known to
  the active server and SERVER_NOT_LINKED if the server isn't logically
  connected.

  The link can be cut by either naming the record or by specifying
  the IP and port of the server. The user first types 'n' to indicate a
  name will be passed or 'ip' to indicate an IP/port pair will be
  passed to the server. Once at the server, the server looks for the correct
  record based on the available information.

- register {name} {port}
  Assigns the given name on the server and registers the client's
  IP and the port on which it will listen for messages. May
  return a NAME_ALREADY_REGISTERED error if that server has registered
  the given name.

- unregister {name}
  Assigns the given name on the server and registers the client's
  IP and the port on which it will listen for messages. May
  return a FAIL_WHALE error if the user is unregistering a name
  that doesn't belong to him/her, or a NAME_NOT_FOUND error if
  the name wasn't found.


- list {name-list} {server-list}
  This lists off all the registered names that the active
  server knows about. In addition to its own names, it may
  return names that it has heard about through its links.

  name-list and server-list are either comma-deliminated
  strings or the wildcard (*). The server returns results
  appropriately to the client.

- send {name} [server] {message}
  This sends a message to the indicated recipient located
  on the indicated server. It makes a best-effort to do
  so; it does not guarantee the named clients receive or
  read the mail. It sends the list to its links as needed.

  If the user so chooses, server can be left unspecified, which
  indicates that the user should be sought on the active server.

- neighbors [server-list]
  This lists off all the active links for the given list of servers. If
  left empty, this only gets the active links for the active server. The
  client gets notification that the request was received; the client gets
  the actual data when a server sends the data to the client via a message.

  Note that the client MUST have a name registered with the active server
  to receive information. A MUST_HAVE_NAME error is thrown if no name
  is associated with the client.


- forwarding [server-list]
  This lists off all the active links for the given list of servers. If
  left empty, this only gets the active links for the active server. The
  client gets notification that the request was received; the client gets
  the actual data when a server sends the data to the client via a message.

  Note that the client MUST have a name registered with the active server
  to receive information. A MUST_HAVE_NAME error is thrown if no name
  is associated with the client.

- quit
  Closes the client application. The server continues to run.

- kill
  Closes the server application. The client application continues to
  run, but the last known server IP address is discarded (since the
  server has shut down).

============================================
 5. Messages
============================================

a. Basic Structure

The following represent the messages between client and server during an
exchange. The basic structure of these messages is

DIRECTION COMMAND [[name] [IP:port] [args]] [{SUCCESS | ERROR code}]

where:

    1. DIRECTION = SND (for initial requests) or RCV (for acknowledgements);
    2. COMMAND = one of the commands listed later in this section;
    3. [name] [port] [args] = a name, IP/port and list of optional arguments;
    4. {SUCCESS| ERROR code} = a status string indicating successful completion
       of the specified task or a specific error condition.

Typically, for RCV messages, there are no additional arguments; there is only
the status message. Conversely SND messages do not have status messages but
will have some sort of argument list.

With the LINK, UNLINK, REGISTER, UNREGISTER, and SEND messages are further
messages used by the server to communicate with its peers. These are known
as Control Messages. They are included here for completeness but are
mentioned very little, as their purpose is mostly to inform servers
on how to handle requests.

One key element of the Control Messages, however, is the tid field, which
is almost always present. This is used to distinguish messages passed
between servers, preventing uncontrolled flooding. The tid consists
of an integer unique to the originating server, plus the server's IP
and port. It is in the format #-IP:port. Each server maintains some
history of past requests. If it is seen again, the message is discarded.

b. Types of Messages

  i.  INSERT

    SND INSERT {name} {IP:port}
    RCV INSERT {SUCCESS | ERROR code}

    INSERT inserts the name/IP:port pair into the records list
    if a record does not exist with the given name. If the name
    currently exists, a FAIL_WHALE error code is generated (see
    below).

 ii.  DELETE

    SND DELETE {name} { {IP|"null"}:{port|0} }
    RCV DELETE  {SUCCESS | ERROR code}

    DELETE deletes the specified record, if one can be found. The
    only field required to delete a record is the name, but the
    server will attempt to match against records with as much
    information is supplied. Thus, if a user supplies an IP address
    and no port, then the server will search for the record with the
    given name AND IP address. If a port is supplied, that is checked
    along with the name (and IP address, if requested by the user).

    If no records are found, a RECORD_NOT_FOUND error is sent to the
    client.

iii.  GET

    SND GET {nameRegex} {IPregex}
    RCV GET {#records} {SUCCESS | ERROR code}

    GET indicates to the server to retrieve records off the name
    and IP regular expressions entered by the user. This request does
    not actually retrieve records - a successful GET is followed by
    one or more TRANSMIT messages (see below) - but is used to see
    if records do exist.

    When the server receives a GET, it processes the regular expressions
    and then attempts to match records based off of them. If there are
    any records the server will return with the number of records and SUCCESS
    and then begin sending TRANSMIT messages. If there are no records,
    #records = 0 and a "record not found" error is returned.

 iv.  TRANSMIT

    SND TRANSMIT { {YAH|NAW} {name IP:port}+ }
    RCV TRANSMIT {SUCCESS | ERROR code}

    TRANSMIT messages follow a successful GET acknowledgement. name
    and IP:port fields are unused here; only the args field is needed.

    Within the args field, two types of fields exist. The first is an
    indication of whether or not the current packet is the last such packet
    of records. YAH means there are no more records, while NAW means the
    opposite. This indicates to the client whether or not all records
    have been transmitted.

    The second lists of all the records found by the server. The server
    lists the name of the record and the IP and port of the record for all
    records returned.

  v. LINK

    SND LINK name
    RCV LINK name {SUCCESS | ERROR code}

    DIR CTRL_CONNECT tid # {client_list} {SUCCESS | ERROR code}

    LINK indicates that the current server should link with another
    server. A RCV is sent when it is determined if the link can be
    established or not. The client does not block for the server
    to establish the link.

    The control message is used to exchange the client lists
    of the two servers. These messages are passed between the
    servers without blocking the user or server. 

 vi. UNLINK

    SND UNLINK name
    RCV UNLINK name {SUCCESS | ERROR code}

    DIR CTRL_DISCONNECT tid name {SUCCESS | ERROR code}    

    UNLINK indicates that the current server should disconnect from another
    server. A RCV is sent when it is determined if the link can be
    destroyed. The client does not block for the server
    to destroy the link.

    The control message is used to indicate that the servers should
    disconnect.

vii. REGISTER

    SND REGISTER name port
    RCV REGISTER name port {SUCCESS | ERROR code}

    DIR CTRL_ADD tid name {SUCCESS | ERROR code}

    REGISTER indicates that the current server should associate
    a given name to the current client. The port is the port on
    which the client will listen for messages.

    The control message is used to indicate that the name should
    be added to the other servers' knowledge about the active server.


viii.UNREGISTER

     SND UNREGISTER name
     RCV UNREGISTER name {SUCCESS | ERROR code}

     DIR CTRL_RM tid name {SUCCESS | ERROR code}

    UNREGISTER indicates that the current server should disassociate
    a given name with the current client. No further action is needed
    by the client.

    The control message is used to indicate that the name should
    be removed to the other servers' knowledge about the active server.

 ix. LIST

     SND LIST clients servers
     RCV LIST clients servers [names] {SUCCESS | ERROR code}

    LIST asks the current server about names that it knows about.
    The server then produces such a list, indicating the server and
    the name registered there (useful especially for wildcard
    queries). The client WILL block until the server is complete.

    There are no control messages for LIST because the current
    server should have sufficient information to return all the names.


  x. SEND 

     SND SEND client server
     RCV SEND client server message {SUCCESS | ERROR code}

     DIR CTRL_SEND tid client server message {SUCCESS | ERROR code}

    SEND sends a message to the client listed on the listed server.
    The client is not blocked during the operation.

    The control message is used to indicate if the message needs to
    propagate through the network. In the case of a wildcard query
    for the servers, "yes" will be chosen, otherwise "no". This ensures
    that the messages only propagate to the active server's links or the
    entire network as needed.


 xi. SEND_N

     SND SEND_N {-|server-list}
     RCV SEND_N {-|server-list} {SUCCESS | ERROR code}

     DIR CTRL_SEND_N tid client server {SUCCESS | ERROR code}

    SEND_N indicates a request for the active links list for the given
    server list. The client is not blocked during the operation. A '-'
    indicates to return the list for the active server.

    The control message is used to indicate where the message is intended
    to go to the node that received the message. When a node receives the
    message, it checks to see if it is the intended target. If so, it
    generates the information and messages the client. If not, it forwards
    it to the indicated server.


xii. SEND_F

     SND SEND_F {-|server-list}
     RCV SEND_F client server {SUCCESS | ERROR code}

     DIR CTRL_SEND_F tid client server {SUCCESS | ERROR code}


    SEND_F indicates a request for the forwarding table for the given
    server list. The client is not blocked during the operation. A '-'
    indicates to return the table for the active server.

    The control message is used to indicate where the message is intended
    to go to the node that received the message. When a node receives the
    message, it checks to see if it is the intended target. If so, it
    generates the information and messages the client. If not, it forwards
    it to the indicated server.


 xi.  GAMEOVER

    SND GAMEOVER
    RCV GAMEOVER {MSG} {SUCCESS | ERROR code}

    GAMEOVER tells the server to shut down in addition to the client.
    If the acknowledgement returns successfully then both client and
    server shut down. If the server is busy processing then it will
    return a SERVER_BUSY error indicating as such. In such an event
    the client will not shut down and must either try to resend the
    message or simply close itself.

    Note that the server can send any kind of message in response
    to a kill command.

c. Error Codes

There are some error codes defined that may be encountered when using the
system. The following error codes and enumerated types are defined in the
ErrorCode class:

    - 72 (FAIL_WHALE): An unexpected error occurred.

    - 101 (NAME_PREVIOUSLY_REGISTERED): The given name is registered to
      someone else on the server.

    - 102 (NAME_NOT_FOUND): The given name is not registered on the server.

    - 404 (RECORD_NOT_FOUND): The server was unable to find a valid record.
      This message is passed in the DELETE and GET commands.

    - 405 (SERVER_NOT_KNOWN): The server does not know about the given server.

    - 406 (SERVER_NOT_LINKED): The server is not linked with the specified
      server.

    - 407 (SERVER_ALREADY_LINKED): The two servers are already linked logically.

    - 777 (PACKET_EXPLODED): A packet loss was detected by the receiver.

    - 1973 (TIMEOUT): The client waited for a response from the server
      within some time frame but did not get one. Used primarily by the
      client when testing its server configuration.

    - 9876 (SERVER_BUSY): The client has indicated to the server that
      it should shut down (using the GAMEOVER message) but the server cannot
      stop because it is busy processing something.


============================================
 6. Routing Algorithm
============================================

The program uses something similar to a distance-vector algorithm to maintain
the routing information. As a node connects/disconnects, a node's routing
table is referenced to see if there are any changes to be made. If ANY
change is made to the table, the node informs its neighbors of the changes.
The changes propagate until the nodes do not have any changes to be made.

In addition, the algorithm implements a simple poisoned reverse. When
unlinking from a neighbor, a node advertises that it cannot reach that
neighbor anymore by setting its hop count to -1 and setting the next node
field to '-'. This in turn ensures that nodes do not attempt to go through
the broken link.

============================================
 7. Test Cases
============================================

The following are test cases that can be used to test the system
functionality.

INSERT
- insert test 1.1.1.1 1234 - should succeed
- insert test 2.21.245.92 5462 - should fail, 'test' already exists
- insert test1 2.21.245.92 5462 - should succeed
- insert test2 43.34.65.65 1928 - should succeed
- insert test3 42.42.42.42 7373 - should succeed
- insert test4 192.168.6.1 1111 - should succeed
- insert test5 75.75.75.75 3192 - should succeed

DELETE
- delete test56 - should fail, no record named 'test5'
- delete test2 - should succeed, record exists
- delete test 2.2.2.2 1234 - should fail, IP address does not match record's
- delete test 1.1.1.1 2134 - should fail, port does not match record's
- delete test 1.1.1.1 1234 - should succeed, all fields match

GET/TRANSMIT
- find test *.*.*.* - should fail, no records named 'test'
- find * *.*.*.* - should find test1, test3-test5
- find * 4*.*.42.* - should find test3

GAMEOVER
- kill - should return with message "game over, man! game over!"

LINK
create a server as specified by the name serv1 in Records.db. Then

- link serv1 - no failure
- link serv1 - will return SERVER_ALREADY_LINKED

UNLINK
- unlink serv1
- unlink NAN - SERVER_NOT_KNOWN error


REGISTER
- register npa - no failure
- register npa - NAME_PREVIOUSLY_REGISTERED error

UNREGISTER
- unregister npa - no failure
- unlink serv2 - will return NAME_NOT_FOUND


LIST
- input '*', '*' when prompted after registering a name

SEND
- input '*', '*', 'This is a test' when prompted after registering a name
